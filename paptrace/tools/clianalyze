#!/usr/bin/env python3

import argparse
import copy
import json
import pprint
from sympy.parsing.sympy_parser import parse_expr


# Globals used by trace analysis.
g_f_ids = {}
g_s_ids = {}
g_exprs = {}


def load_traces(trace_file):
    with open(trace_file, "r") as f:
        data = json.load(f)
    return data["traces"]


def context_analysis(traces):
    def populate_sig_map(tree, sig_map):
        if isinstance(tree, list):
            for item in tree:
                populate_sig_map(item, sig_map)
        elif isinstance(tree, dict):
            if "sig" in tree:
                k = tree["sig"]
                if k not in sig_map:
                    sig_map[k] = len(sig_map)
            for key, value in tree.items():
                populate_sig_map(value, sig_map)

    sig_map = {}
    populate_sig_map(traces, sig_map)
    # pprint.pprint(sig_map)
    print(f"Number of unique signatures: {len(sig_map)}")

    def extract_call_nodes(tree, sig_map, call_nodes):
        if isinstance(tree, list):
            for item in tree:
                extract_call_nodes(item, sig_map, call_nodes)
        elif isinstance(tree, dict):
            for key, value in tree.items():
                extract_call_nodes(value, sig_map, call_nodes)
            if "type" in tree and "Call" in tree["type"]:
                tree["id"] = sig_map[tree["sig"]]
                call_nodes.append(copy.deepcopy(tree))
                tree.pop("children")

    call_nodes = []
    extract_call_nodes(traces, sig_map, call_nodes)
    # pprint.pprint(call_nodes)
    print(f"Number of call nodes: {len(call_nodes)}")

    unique_call_nodes = []
    unique_call_node_strs = {}
    for call_node in call_nodes:
        call_node_str = str(call_node)
        if not call_node_str in unique_call_node_strs:
            unique_call_node_strs[call_node_str] = 1
            unique_call_nodes.append(call_node)
    # pprint.pprint(unique_call_nodes)
    print(f"Number of uniq. call nodes: {len(unique_call_nodes)}")

    call_map = {}
    for call_node in unique_call_nodes:
        id = call_node["id"]
        if not id in call_map:
            call_map[id] = {"sig": call_node["sig"], "ctxs": {}}
        ctx = str(call_node["params"])
        if not ctx in call_map[id]["ctxs"]:
            call_map[id]["ctxs"][ctx] = len(call_map[id]["ctxs"])
        else:
            raise Exception(f"Duplicate call node ctx: {ctx}!")
    pprint.pprint(call_map)
    print(f"Number of top-level call map entries: {len(call_map)}")


def trace_analysis(traces):
    def analyze_trace(trace):
        console_sep = "-" * 80
        print(f"\n{console_sep}")

        def to_s_id(id):
            global g_s_ids
            if id not in g_s_ids:
                g_s_ids[id] = f"s{id}"
            return g_s_ids[id]

        def to_summary(obj, symb="", indent=""):
            def to_params_str(params):
                return ", ".join([f"{x['name']}={x['value']}" for x in params])

            summary = ""
            obj_type = obj["type"]
            if obj_type == "CalleeExpr" or obj_type == "CallerExpr":
                params = f"{{{to_params_str(obj['params'])}}}"
                summary += f"{indent}{symb}{obj['sig']} @ {params}"
            elif "Stmt" in obj_type:
                summary += f"{indent}{symb}{obj_type} ({to_s_id(obj['id'])})"
            if "children" in obj:
                for child in obj["children"]:
                    summary += f"\n{to_summary(child, '+ ', indent + '  ')}"
            return summary

        summary = to_summary(trace)
        print(f"Trace summary:\n{summary}")

        def to_f_id(sig):
            global g_f_ids
            if sig not in g_f_ids:
                g_f_ids[sig] = f"f{len(g_f_ids)}"
            return g_f_ids[sig]

        def to_expr_list(obj):
            expr = []
            if "children" in obj and len(obj["children"]) > 0:
                for child in obj["children"]:
                    expr.extend(to_expr_list(child))
            else:
                obj_type = obj["type"]
                if "Stmt" in obj_type:
                    expr.append(to_s_id(obj["id"]))
                elif "Call" in obj_type:
                    expr.append(to_f_id(obj["sig"]))
            return expr

        def to_expr(trace):
            rhs = " + ".join(to_expr_list(trace))
            return f"{to_f_id(trace['sig'])} = {rhs}"

        print(f"\nTrace expr:")
        expr_str = to_expr(trace)
        print(f"(orig.) {expr_str}")

        rhs = " + ".join(to_expr_list(trace))
        expr = parse_expr(rhs)
        print(f"(simp.) {to_f_id(trace['sig'])} = {expr}")

        global g_exprs
        f_id = to_f_id(trace["sig"])
        if f_id not in g_exprs:
            g_exprs[f_id] = {}
        n = int(trace["params"][0]["value"])
        g_exprs[f_id][n] = expr

    for trace in traces:
        analyze_trace(trace)


def main():
    parser = argparse.ArgumentParser(
        description="Command line analysis utility for paptrace."
    )
    parser.add_argument(
        "analysis",
        choices=["context", "trace"],
        help="Type of analysis to perform",
    )
    parser.add_argument(
        "trace_file", help="Path to paptrace generate JSON file."
    )
    args = parser.parse_args()

    traces = load_traces(args.trace_file)
    if args.analysis == "context":
        context_analysis(traces)
    elif args.analysis == "trace":
        trace_analysis(traces)


if __name__ == "__main__":
    main()
