#!/usr/bin/env python3

import argparse
import copy
import json
import pprint
import tempfile
import pathlib

from sympy.parsing.sympy_parser import parse_expr
import graphviz


def load_traces(trace_file):
    with open(trace_file, "r") as f:
        data = json.load(f)
    return data["traces"]


def context_analysis(traces):
    """Summarize the contexts encountered for each call node."""

    def populate_sig_map(tree, sig_map):
        if isinstance(tree, list):
            for item in tree:
                populate_sig_map(item, sig_map)
        elif isinstance(tree, dict):
            if "sig" in tree:
                k = tree["sig"]
                if k not in sig_map:
                    sig_map[k] = len(sig_map)
            for key, value in tree.items():
                populate_sig_map(value, sig_map)

    sig_map = {}
    populate_sig_map(traces, sig_map)
    # pprint.pprint(sig_map)
    print(f"Number of unique signatures: {len(sig_map)}")

    def extract_call_nodes(tree, sig_map, call_nodes):
        if isinstance(tree, list):
            for item in tree:
                extract_call_nodes(item, sig_map, call_nodes)
        elif isinstance(tree, dict):
            for key, value in tree.items():
                extract_call_nodes(value, sig_map, call_nodes)
            if "type" in tree and "Call" in tree["type"]:
                tree["id"] = sig_map[tree["sig"]]
                call_nodes.append(copy.deepcopy(tree))
                tree.pop("children")

    call_nodes = []
    extract_call_nodes(traces, sig_map, call_nodes)
    # pprint.pprint(call_nodes)
    print(f"Number of call nodes: {len(call_nodes)}")

    unique_call_nodes = []
    unique_call_node_strs = {}
    for call_node in call_nodes:
        call_node_str = str(call_node)
        if not call_node_str in unique_call_node_strs:
            unique_call_node_strs[call_node_str] = 1
            unique_call_nodes.append(call_node)
    # pprint.pprint(unique_call_nodes)
    print(f"Number of uniq. call nodes: {len(unique_call_nodes)}")

    call_map = {}
    for call_node in unique_call_nodes:
        id = call_node["id"]
        if not id in call_map:
            call_map[id] = {"sig": call_node["sig"], "ctxs": {}}
        ctx = str(call_node["params"])
        if not ctx in call_map[id]["ctxs"]:
            call_map[id]["ctxs"][ctx] = len(call_map[id]["ctxs"])
        else:
            raise Exception(f"Duplicate call node ctx: {ctx}!")
    pprint.pprint(call_map)
    print(f"Number of top-level call map entries: {len(call_map)}")


def trace_analysis(traces):
    """Print a visual description and expression for each trace."""
    g_f_ids = {}
    g_s_ids = {}
    g_exprs = {}

    def analyze_trace(trace):
        console_sep = "-" * 80
        print(f"\n{console_sep}")

        def to_s_id(id):
            if id not in g_s_ids:
                g_s_ids[id] = f"s{id}"
            return g_s_ids[id]

        def to_summary(obj, symb="", indent=""):
            def to_params_str(params):
                return ", ".join([f"{x['name']}={x['value']}" for x in params])

            summary = ""
            obj_type = obj["type"]
            if obj_type == "CalleeExpr" or obj_type == "CallerExpr":
                params = f"{{{to_params_str(obj['params'])}}}"
                summary += f"{indent}{symb}{obj['sig']} @ {params}"
            elif "Stmt" in obj_type:
                summary += f"{indent}{symb}{obj_type} ({to_s_id(obj['id'])})"
            if "children" in obj:
                for child in obj["children"]:
                    summary += f"\n{to_summary(child, '+ ', indent + '  ')}"
            return summary

        summary = to_summary(trace)
        print(f"Trace summary:\n{summary}")

        def to_f_id(sig):
            if sig not in g_f_ids:
                g_f_ids[sig] = f"f{len(g_f_ids)}"
            return g_f_ids[sig]

        def to_expr_list(obj):
            expr = []
            if "children" in obj and len(obj["children"]) > 0:
                for child in obj["children"]:
                    expr.extend(to_expr_list(child))
            else:
                obj_type = obj["type"]
                if "Stmt" in obj_type:
                    expr.append(to_s_id(obj["id"]))
                elif "Call" in obj_type:
                    expr.append(to_f_id(obj["sig"]))
            return expr

        def to_expr(trace):
            rhs = " + ".join(to_expr_list(trace))
            return f"{to_f_id(trace['sig'])} = {rhs}"

        print(f"\nTrace expr:")
        expr_str = to_expr(trace)
        print(f"(orig.) {expr_str}")

        rhs = " + ".join(to_expr_list(trace))
        expr = parse_expr(rhs)
        print(f"(simp.) {to_f_id(trace['sig'])} = {expr}")

        f_id = to_f_id(trace["sig"])
        if f_id not in g_exprs:
            g_exprs[f_id] = {}
        n = int(trace["params"][0]["value"])
        g_exprs[f_id][n] = expr

    for trace in traces:
        analyze_trace(trace)


def path_analysis(traces):
    id_map = {}
    call_nodes = {}
    orig_traces = copy.deepcopy(traces)

    def extract_call_nodes(trace, id_map, call_nodes):
        # DFS for call nodes.
        if has_children := "children" in trace:
            for child in trace["children"]:
                extract_call_nodes(child, id_map, call_nodes)
        if "Call" in trace["type"]:

            def get_key_for_value(dict_, value):
                for k, v in dict_.items():
                    if v == value:
                        return k
                return None

            id = id_map.setdefault(trace["id"], f"f_{len(id_map)}")
            trace["id"] = id
            call_node = call_nodes.setdefault(
                id, {"sig": trace["sig"], "params": {}, "paths": {}, "ctxs": {}}
            )
            param_id = get_key_for_value(call_node["params"], trace["params"])
            if param_id is None:
                param_id = len(call_node["params"])
                call_node["params"][param_id] = trace["params"]
            path_id = get_key_for_value(call_node["paths"], trace["children"])
            if path_id is None:
                path_id = len(call_node["paths"])
                call_node["paths"][path_id] = trace["children"]
            ctx = {"params": param_id, "paths": path_id}
            ctx_id = get_key_for_value(call_node["ctxs"], ctx)
            if ctx_id is None:
                ctx_id = len(call_node["ctxs"])
                call_node["ctxs"][ctx_id] = ctx

            del trace["sig"]
            del trace["params"]
            del trace["children"]
            trace["ctx"] = ctx_id

    [extract_call_nodes(trace, id_map, call_nodes) for trace in traces]

    print("\n====================")
    print("Call nodes:")
    print("--------------------")
    pprint.pprint(call_nodes)

    print("\n====================")
    print("Minimized traces:")
    print("--------------------")
    pprint.pprint(traces)

    def rebuild_trace(call_nodes, trace):
        id = trace["id"]
        children = []
        if "ctx" in trace:
            ctx = call_nodes[id]["ctxs"][trace["ctx"]]
            children = call_nodes[id]["paths"][ctx["paths"]]
        else:
            children = trace["children"]
        rebuilt_children = [
            rebuild_trace(call_nodes, child) for child in children
        ]
        rebuilt_node = {"id": trace["id"], "children": rebuilt_children}
        return rebuilt_node

    rebuilt_traces = [rebuild_trace(call_nodes, trace) for trace in traces]

    def to_rebuilt_style(id_map, trace):
        children = []
        if "children" in trace:
            children = [
                to_rebuilt_style(id_map, child) for child in trace["children"]
            ]
        old_id = trace["id"]
        new_id = id_map[old_id] if old_id in id_map else old_id
        return {"id": new_id, "children": children}

    expected_traces = [to_rebuilt_style(id_map, trace) for trace in orig_traces]

    print("\n====================")
    print(f"Rebuilt traces match expected: {rebuilt_traces == expected_traces}")


def dot_analysis(traces):
    def to_graph_features(trace, nodes, edges):
        id_ = trace["id"]
        if "sig" in trace:
            nodes.add((id_, trace["sig"]))
        else:
            nodes.add((id_, trace["type"]))
        if "children" in trace:
            prev_child = id_
            for child in trace["children"]:
                to_graph_features(child, nodes, edges)
                child_id = child["id"]
                edges.add((prev_child, child_id))
                prev_child = child_id

    graph = graphviz.Digraph(comment="DOT Analysis")
    cnt = 0
    for trace in traces:
        nodes = set()
        edges = set()
        to_graph_features(trace, nodes, edges)
        with graph.subgraph(name=f"cluster_{cnt}") as subg:
            for node in nodes:
                subg.node(str(node[0]), str(node[1]))
            for edge in edges:
                subg.edge(str(edge[0]), str(edge[1]))
        cnt += 1
    with tempfile.TemporaryDirectory() as tmpdirname:
        graph_path = pathlib.Path(tmpdirname) / "graph.gv"
        print(f"Writing graph to: {graph_path}")
        graph.render(graph_path, view=True)
        input("Press enter to continue ...")


def main():
    parser = argparse.ArgumentParser(
        description="Command line analysis utility for paptrace."
    )
    parser.add_argument(
        "analysis",
        choices=["context", "trace", "path", "dot"],
        help=(
            "Type of analysis to perform. See the README in this tool's source"
            " directory for more info."
        ),
    )
    parser.add_argument(
        "trace_file", help="Path to paptrace generate JSON file."
    )
    args = parser.parse_args()

    traces = load_traces(args.trace_file)
    if args.analysis == "context":
        context_analysis(traces)
    elif args.analysis == "trace":
        trace_analysis(traces)
    elif args.analysis == "path":
        path_analysis(traces)
    elif args.analysis == "dot":
        dot_analysis(traces)


if __name__ == "__main__":
    main()
